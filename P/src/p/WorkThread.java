package p;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author prigs
 */

//process - это обычно исполняемый программа(процесс)(выделяется общая память,выполняется код,свои ресурсы) и существует 1 поумолчанию thread(общий(главный) поток).
//thread (поток)- это исполнение подпрограммы(кусок кода) паралельно внутри программы(процесса)- попадает под управления процесса(далее ЦПУ) - т.е. несколько потоков одновременно выполняется.
//обычно загрузка данных и распараллеливание вычеслений используется потоки.
//2 метода создания потоков Class Thread - создание потока с методами реализации,interface Runnable - чтобы создать поток нужно передать его на вход потоку(thread).
//http://ru.wikipedia.org/wiki/Thread
//http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C

public class WorkThread {

    public static void startThread() throws InterruptedException {
       //2 способ - более гибкий(можо наследоваться),но нужно хранить ссылку и на объект интерфейса и  на объект созданного потока
       //создание потока
        Thread tm2 = new Thread(new MyThreadMetod2());
        tm2.start();// запуск потока

       //1 способ
       //создание потока
       MyThreadMetod1 tm1 = new MyThreadMetod1();
       tm1.start();

       //3 способ
       //создание потока
       //ананимные классы
        Thread tm3 = new Thread(new Runnable() {

            public void run() {
                //выполнения команд потока
                //throw new UnsupportedOperationException("Not supported yet.");
            }
        });
        tm3.start();

    //остановка выполнение основного потока до выполнения конкретного потока (в примерке для выполнения всех 3 потоков)
    //последовательно действий
    // запуск главного потока main
    //заснул main
    //паралельно работаю 3 потока
    //заснул main,1 поток отработал,если 2 поток еще не выполнился
    //...
    //продолжение работы основного потока
        tm1.join();
        tm2.join();
        tm3.join();
    //Deadlock - пример - 2..n потока вызвали методы synchronized друг друга и заснули и остановились
    //Решение проблемы: пожертвовать (убить один из потоков) и использовать synchronized не для целого метода ,а для блока в методе
    //Livelock - пример - 2..n потока вызвали методы synchronized друг друга и работаю и не уснули(остановились),а жду освобождение методов
    //race conditions - 2..n потока одновременно обращаются (например к одной переменной другого объекта) и мы не знаем кто первый обратиться к этой переменной
    //strarvetion - в одном из потоков не освободили объект(ресурс),другие не могу обратиться к этому объекту(ресурсу)
    }

}

class MyThreadMetod2 implements Runnable{

public void run()
    {
    //выполнения команд потока
    }
}

class MyThreadMetod1 extends Thread{

@Override
public void run()
    {
        //выполнения команд потока
        try {
            //для остановки на время поток
            Thread.sleep(1000); // на 1 сек
        } catch (InterruptedException ex) {
            Logger.getLogger(MyThreadMetod1.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}

//использование синхранизации - передача последовательно(random) выполнения методов между потоками.
//передача происходит между потоками при проверки лога(т.е проверка объекта(Counter с = new Counter()) на выполнения одного из методов  synchronized)
class Counter{
int c1=0;
int c2=0;
Object look1 = new Object();
Object look2 = new Object();

public void inc()
    {    synchronized(look1) //синхранизации часть кода метод -как только я запустил этот метод др. потоки смогу работать с другими методами и с этим методом, но не смогут работать с объектом look1
        {
         c1++;
        }
    }
public void dec()
    { synchronized(look2)//синхранизации часть кода метод -как только я запустил этот метод др. потоки смогу работать с другими методами и с этим методом, но не смогут работать с объектом look2
      {
          c2--;
      }

    }

public synchronized int getC() //синхранизации весь метод - как только я запустил этот метод др. потоки не смогу работать с другими методами (т.е c объектом с,где (Counter с = new Counter())
    {return c1+c2;}
}

